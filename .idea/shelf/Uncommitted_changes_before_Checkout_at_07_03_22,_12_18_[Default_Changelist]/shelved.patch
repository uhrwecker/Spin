Index: one_ray_solver/ode/solver.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from scipy.integrate import odeint\nimport numpy as np\nimport contextlib\nimport os\nimport sys\n\nfrom one_ray_solver.ode import schwarzschild\n\n\ndef fileno(file_or_fd):\n    fd = getattr(file_or_fd, 'fileno', lambda: file_or_fd)()\n    if not isinstance(fd, int):\n        raise ValueError(\"Expected a file (`.fileno()`) or a file descriptor\")\n    return fd\n\n@contextlib.contextmanager\ndef stdout_redirected(to=os.devnull, stdout=None):\n    \"\"\"\n    https://stackoverflow.com/a/22434262/190597 (J.F. Sebastian)\n    \"\"\"\n    if stdout is None:\n       stdout = sys.stdout\n\n    stdout_fd = fileno(stdout)\n    # copy stdout_fd before it is overwritten\n    #NOTE: `copied` is inheritable on Windows when duplicating a standard stream\n    with os.fdopen(os.dup(stdout_fd), 'wb') as copied:\n        stdout.flush()  # flush library buffers that dup2 knows nothing about\n        try:\n            os.dup2(fileno(to), stdout_fd)  # $ exec >&to\n        except ValueError:  # filename\n            with open(to, 'wb') as to_file:\n                os.dup2(to_file.fileno(), stdout_fd)  # $ exec > to\n        try:\n            yield stdout # allow code to be run with the redirected stdout\n        finally:\n            # restore stdout to its previous value\n            #NOTE: dup2 makes stdout_fd inheritable unconditionally\n            stdout.flush()\n            os.dup2(copied.fileno(), stdout_fd)  # $ exec >&copied\n\n\nclass ODESolverSchwazrschild:\n    \"\"\"Base class for solving the Schwarzschild field euqations!\"\"\"\n    def __init__(self, robs, tobs, pobs, l, q, m=1, start=0, stop=70, num=100000, abserr=1e-7, relerr=1e-7,\n                 sign_r=-1, sign_q=1, sign_l=1):\n        self.m = m\n\n        self.t0 = 0\n        self.robs = robs\n        self.tobs = tobs\n        self.pobs = pobs\n\n        self.l = l\n        self.q = q\n\n        self.sign_r = sign_r\n        self.sign_q = sign_q\n        self.sign_l = sign_l\n\n        self.dt, self.dr, self.dtheta, self.dphi = self.get_ic_from_com(l, q,\n                                                                        sign_r=sign_r, sign_q=sign_q, sign_l=sign_l)\n\n        self.start = start\n        self.stop = stop\n        self.num = num\n        self.abserr = abserr\n        self.relerr = relerr\n        self.sigma = np.linspace(self.start, self.stop, num=self.num)\n\n    def solve(self):\n        \"\"\"\n            Main routine for solving with the previously specified initial conditions\n            :return: iter; [sigma, result] where sigma is the array of affine parameter, and result includes all [x, x']\n        \"\"\"\n        psi = np.array([self.t0, self.dt, self.robs, self.dr, self.tobs, self.dtheta, self.pobs, self.dphi])\n\n        with stdout_redirected():\n            result = odeint(schwarzschild.geod, psi, self.sigma, args=(self.m, ), atol=self.abserr, rtol=self.relerr)\n\n        return self.sigma, result\n\n    def get_ic_from_com(self, l, q, sign_r=-1, sign_l=1, sign_q=1):\n        dt = 1 / (1 - 2 * self.m / self.robs)\n\n        dtheta = sign_q * np.sqrt(np.abs(q - l**2 / np.tan(self.tobs)**2)) / self.robs**2\n\n        dr = sign_r * np.sqrt(1 - (q + l**2) / self.robs**2 * (1 - 2 * self.m / self.robs))\n\n        dphi = sign_l * l / (self.robs * np.sin(self.tobs))**2\n\n        return dt, dr, dtheta, dphi\n\n    def change_emission_point(self, r, t, p, recalc=True):\n        self.robs = r\n        self.tobs = t\n        self.pobs = p\n\n        if recalc:\n            self.dt, self.dr, self.dtheta, self.dphi = self.get_ic_from_com(self.l, self.q, self.sign_r, self.sign_l,\n                                                                            self.sign_q)\n\n    def change_signs(self, sign_r, sign_q, sign_l, recalc=True):\n        self.sign_r = sign_r\n        self.sign_q = sign_q\n        self.sign_l = sign_l\n\n        if recalc:\n            self.dt, self.dr, self.dtheta, self.dphi = self.get_ic_from_com(self.l, self.q, self.sign_r, self.sign_l,\n                                                                            self.sign_q)\n\n    def change_constants_of_motion(self, lamda, qu, recalc=True):\n        self.l = lamda\n        self.q = qu\n\n        if recalc:\n            self.dt, self.dr, self.dtheta, self.dphi = self.get_ic_from_com(self.l, self.q, self.sign_r, self.sign_l,\n                                                                            self.sign_q)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/one_ray_solver/ode/solver.py b/one_ray_solver/ode/solver.py
--- a/one_ray_solver/ode/solver.py	(revision dd4e358fdad738d7d71494b411838abb1ef3cf47)
+++ b/one_ray_solver/ode/solver.py	(date 1646651843810)
@@ -89,6 +89,7 @@
 
         dphi = sign_l * l / (self.robs * np.sin(self.tobs))**2
 
+        print(dt, dr, dtheta, dphi)
         return dt, dr, dtheta, dphi
 
     def change_emission_point(self, r, t, p, recalc=True):
