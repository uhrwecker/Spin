Index: one_ray_solver/ode/solver.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from scipy.integrate import odeint\nimport numpy as np\nimport contextlib\nimport os\nimport sys\n\nfrom one_ray_solver.ode import kerr\n\n\ndef fileno(file_or_fd):\n    fd = getattr(file_or_fd, 'fileno', lambda: file_or_fd)()\n    if not isinstance(fd, int):\n        raise ValueError(\"Expected a file (`.fileno()`) or a file descriptor\")\n    return fd\n\n@contextlib.contextmanager\ndef stdout_redirected(to=os.devnull, stdout=None):\n    \"\"\"\n    https://stackoverflow.com/a/22434262/190597 (J.F. Sebastian)\n    \"\"\"\n    if stdout is None:\n       stdout = sys.stdout\n\n    stdout_fd = fileno(stdout)\n    # copy stdout_fd before it is overwritten\n    #NOTE: `copied` is inheritable on Windows when duplicating a standard stream\n    with os.fdopen(os.dup(stdout_fd), 'wb') as copied:\n        stdout.flush()  # flush library buffers that dup2 knows nothing about\n        try:\n            os.dup2(fileno(to), stdout_fd)  # $ exec >&to\n        except ValueError:  # filename\n            with open(to, 'wb') as to_file:\n                os.dup2(to_file.fileno(), stdout_fd)  # $ exec > to\n        try:\n            yield stdout # allow code to be run with the redirected stdout\n        finally:\n            # restore stdout to its previous value\n            #NOTE: dup2 makes stdout_fd inheritable unconditionally\n            stdout.flush()\n            os.dup2(copied.fileno(), stdout_fd)  # $ exec >&copied\n\n\nclass ODESolverKerr:\n    \"\"\"Base class for solving the Kerr field euqations!\"\"\"\n    def __init__(self, robs, tobs, pobs, l, q, m=1, bha=0., start=0, stop=70, num=100000, abserr=1e-7, relerr=1e-7,\n                 sign_r=-1, sign_q=1, sign_l=1):\n        self.m = m\n        self.bha = bha\n\n        self.t0 = 0\n        self.robs = robs\n        self.tobs = tobs\n        self.pobs = pobs\n\n        self.l = l\n        self.q = q\n\n        self.sign_r = sign_r\n        self.sign_q = sign_q\n        self.sign_l = sign_l\n\n        self.dt, self.dr, self.dtheta, self.dphi = self.get_ic_from_com(l, q,\n                                                                        sign_r=sign_r, sign_q=sign_q, sign_l=sign_l)\n\n        self.start = start\n        self.stop = stop\n        self.num = num\n        self.abserr = abserr\n        self.relerr = relerr\n        self.sigma = np.linspace(self.start, self.stop, num=self.num)\n\n    def solve(self):\n        \"\"\"\n            Main routine for solving with the previously specified initial conditions\n            :return: iter; [sigma, result] where sigma is the array of affine parameter, and result includes all [x, x']\n        \"\"\"\n        psi = np.array([self.t0, self.dt, self.robs, self.dr, self.tobs, self.dtheta, self.pobs, self.dphi])\n\n        with stdout_redirected():\n            result = odeint(kerr.geod, psi, self.sigma, args=(self.m, self.bha), atol=self.abserr, rtol=self.relerr)\n\n        return self.sigma, result\n\n    def get_ic_from_com(self, l, q, sign_r=-1, sign_l=1, sign_q=1):\n        delta = self.robs ** 2 - 2 * self.robs + self.bha ** 2\n        sigma = self.robs ** 2 + self.bha ** 2 * np.cos(self.tobs) ** 2\n        T_func = self.robs ** 2 + self.bha ** 2 - l * self.bha\n        R_func = self.robs ** 4 - (q + l ** 2 - self.bha ** 2) * self.robs ** 2 + \\\n                 2 * (q + (l - self.bha) ** 2) * self.robs - self.bha ** 2 * q\n        Th_func = q + self.bha ** 2 * np.cos(self.tobs) ** 2 - l ** 2 / np.tan(self.tobs) ** 2\n\n        dt = 1 / sigma * (- self.bha * (self.bha * np.sin(self.tobs) ** 2 - l) +\n                          (self.robs ** 2 + self.bha ** 2) * T_func / delta)\n\n        dtheta = sign_q / sigma * np.sqrt(Th_func)\n\n        dr = sign_r / sigma * np.sqrt(R_func)\n\n        dphi = sign_l / sigma * (- self.bha + l / np.sin(self.tobs) ** 2 + self.bha * T_func / delta)\n\n        print(dt, dtheta, dr, dphi)\n\n        return dt, dr, dtheta, dphi\n\n    def change_emission_point(self, r, t, p, recalc=True):\n        self.robs = r\n        self.tobs = t\n        self.pobs = p\n\n        if recalc:\n            self.dt, self.dr, self.dtheta, self.dphi = self.get_ic_from_com(self.l, self.q, self.sign_r, self.sign_l,\n                                                                            self.sign_q)\n\n    def change_signs(self, sign_r, sign_q, sign_l, recalc=True):\n        self.sign_r = sign_r\n        self.sign_q = sign_q\n        self.sign_l = sign_l\n\n        if recalc:\n            self.dt, self.dr, self.dtheta, self.dphi = self.get_ic_from_com(self.l, self.q, self.sign_r, self.sign_l,\n                                                                            self.sign_q)\n\n    def change_constants_of_motion(self, lamda, qu, recalc=True):\n        self.l = lamda\n        self.q = qu\n\n        if recalc:\n            self.dt, self.dr, self.dtheta, self.dphi = self.get_ic_from_com(self.l, self.q, self.sign_r, self.sign_l,\n                                                                            self.sign_q)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/one_ray_solver/ode/solver.py b/one_ray_solver/ode/solver.py
--- a/one_ray_solver/ode/solver.py	
+++ b/one_ray_solver/ode/solver.py	
@@ -98,7 +98,7 @@
 
         dphi = sign_l / sigma * (- self.bha + l / np.sin(self.tobs) ** 2 + self.bha * T_func / delta)
 
-        print(dt, dtheta, dr, dphi)
+        print(dt, dr, dtheta, dphi)
 
         return dt, dr, dtheta, dphi
 
